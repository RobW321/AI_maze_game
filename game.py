from heapq import heappush, heappop
from random import random
import random
import pygame
from pygame import Rect
import time
import heapq
from copy import deepcopy
from collections import deque

from agent import plan_next_move
from goblin import move_goblin_towards_agent

# Throughout this project, the terms "agent" and "player" refer to the same entity.


def bfs_reachable(grid, start):
    """
    Performs a BFS on the given grid to determine every cell that
    is reachable from the player's start position. Used to determine if 
    a generated maze is actually solvable for both the agent and
    the goblin.
    
    :param grid: The grid for examination
    :param start: The starting location of the agent
    """
    rows, cols = len(grid), len(grid[0])
    q = deque([tuple(start)])
    visited = set([tuple(start)])

    while q:
        r, c = q.popleft()
        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:
            nr, nc = r + dr, c + dc
            if (0 <= nr < rows and 0 <= nc < cols and 
                grid[nr][nc] != "W" and 
                (nr, nc) not in visited):
                visited.add((nr, nc))
                q.append((nr, nc))

    return visited


from agent import plan_next_move
from goblin import move_goblin_towards_agent


class GridGame:
    def __init__(self, rows=50, cols=50, cell_size=14, render_delay=0.1, gui=True):
        # If too low row and column values were given, override them to be the minimum
        if rows < 5:
            rows = 5
        if cols < 5:
            cols = 5
        self.rows = rows
        self.cols = cols
        self.cell_size = cell_size
        self.screen_size = self.screen_size = (cols * cell_size, rows * cell_size)
        self.delay = render_delay
        self.gui = gui

        # Colors
        self.COLOR_WALL = (139, 69, 19)  # brown
        self.COLOR_FLOOR = (169, 169, 169)  # gray
        self.COLOR_PLAYER = (255, 255, 0)  # yellow
        self.COLOR_GOBLIN = (0, 255, 0)  # green
        self.COLOR_EXIT = (255, 0, 0)  # red
        self.COLOR_GRID = (0, 0, 0)  # black grid lines
        self.BLACK = self.COLOR_GRID
        self.WHITE = (255, 255, 255)  # white


        # Player position
        self.pos = [0, 0]

        # Pygame setup
        if gui:
            pygame.init()
            pygame.display.init()
            self.screen = pygame.display.set_mode(self.screen_size)
            pygame.display.set_caption("Maze")
            self.clock = pygame.time.Clock()

        # Generate maze map
        self.grid = None

        # Find player and exit
        self.player_pos = None
        self.exit_pos = None
        self.goblin_pos = None

        while True:
            self.grid = self._generate_maze()
            self.player_pos = self._find_spawn()
            self.exit_pos = self._place_exit()
            self.goblin_pos = self._place_goblin()

            if self._validate_world():
                break   # valid maze



    def _draw_grid(self):
        if not self.gui:
            return
        for row in range(self.rows):
            for col in range(self.cols):
                rect = Rect(col * self.cell_size,
                            row * self.cell_size,
                            self.cell_size,
                            self.cell_size)

                # Choose color based on tile type
                tile = self.grid[row][col]
                if [row, col] == self.player_pos:
                    color = self.COLOR_PLAYER
                elif [row, col] == self.exit_pos:
                    color = self.COLOR_EXIT
                elif [row, col] == self.goblin_pos:
                    color = self.COLOR_GOBLIN
                elif tile == "W":
                    color = self.COLOR_WALL
                else:
                    color = self.COLOR_FLOOR

                pygame.draw.rect(self.screen, color, rect)
                pygame.draw.rect(self.screen, self.COLOR_GRID, rect, width=1)
       # pygame.display.flip()


    def _generate_maze(self):
        """
        Generates a dungeon/map by building a 2D python list.
        The list is of size self.rows by self.cols. This method
        generates each entry of the list 1 at a time. For each
        entry, it will assign it the string "F" with 0.75 probability,
        denoting that cell as a floor. With 0.25 probability, it will
        assign it the string "W", denoting it as a Wall.
        """
        grid = []
        for row in range(self.rows):
            grid_row = []
            for col in range(self.cols):
                # Randomly choose wall or floor
                if random.random() < 0.25:  # 25% chance of wall
                    grid_row.append("W")
                else:
                    grid_row.append("F")
            grid.append(grid_row)
        return grid


    def _find_spawn(self):
        """
        Locates all valid spawning cells for the agent in the left region
        of the dungeon/maze generated by _generate_maze(), and then randomly selects one as the
        spawn point. A valid spawn cell is any cell that isn't a wall.
        """
        potential_spawns = []
        for row in range(self.rows):
            for col in range(5):  # only check first 5 columns
                if self.grid[row][col] == "F":
                    potential_spawns.append([row, col])
        if potential_spawns:
            return random.choice(potential_spawns)
        else:
            return random.choice([(r, c) for r, row in enumerate(self.grid) for c, x in enumerate(row) if x == "F"])



    def _place_exit(self):
        """
        Locates all valid exit cells for the agent in the right region
        of the dungeon/maze generated by _generate_maze(), and then randomly selects one as the
        exit point. A valid exit cell is any cell that isn't a wall.
        """
        potential_exits = []
        for row in range(self.rows - 1, -1, -1):
            for col in range(self.cols - 1, self.cols - 6, -1):
                if self.grid[row][col] == "F":
                    potential_exits.append([row, col])
        if potential_exits:
            return random.choice(potential_exits)
        else:
            return random.choice([(r, c) for r, row in enumerate(self.grid) for c, x in enumerate(row) if x == "F"])


    def _place_goblin(self):
        """
        Locates all valid goblin spawn cells in the middle region of the
        dungeon/maze generated by _generate_maze(), and then randomly selects
        one as the goblin spawn. A valid spawn cell is any cell that isn't a wall.
        """
        potential_goblin_spawns = []
        for row in range(self.rows // 3, 2 * self.rows // 3):
            for col in range(self.cols // 3, 2 * self.cols // 3):
                if self.grid[row][col] == "F":
                    potential_goblin_spawns.append([row, col])
        if potential_goblin_spawns:
            return random.choice(potential_goblin_spawns)
        else:
            return random.choice([(r, c) for r, row in enumerate(self.grid) for c, x in enumerate(row) if x == "F"])
    

    def _validate_world(self):
        reachable = bfs_reachable(self.grid, self.player_pos)

        # Must contain exit
        if tuple(self.exit_pos) not in reachable:
            return False

        # Must contain goblin
        if tuple(self.goblin_pos) not in reachable:
            return False

        # Ensure spawn isn't inside a tiny box
        if len(reachable) < 20:
            return False

        return True

        return random.choice(potential_goblin_spawns)
    

    def _generate_reward_grid(self):
        """
        This method looks at the maze generated by _generate_maze() and creates
        a grid of rewards. Rewards on the grid are associated with their respective
        locations in the maze. For example, the reward stored at row 5 column 3 is
        the reward for being at row 5 column 3.
        """
        if self.grid == None: # Make sure a maze has been generated first
            return None
        
        # Initialize Reward Grid
        reward_grid = deepcopy(self.grid)

        for row in range(self.rows):
            for col in range(self.cols):
                if reward_grid[row][col] == "W": # -100000 Reward for Walls
                    reward_grid[row][col] = -100000
                elif abs(self.goblin_pos[0] - row) <= 5 and abs(self.goblin_pos[1] - col) <= 5: # Reward for being near goblin is based on distance
                    reward_grid[row][col] = min(-10 - abs(self.goblin_pos[0] - 5), -10 - abs(self.goblin_pos[1]))
                elif [row, col] == self.exit_pos: # Reward for winning is really large
                    reward_grid[row][col] == 10000
                else:
                    reward_grid[row][col] = 1 # Reward for a normal state is small but positive
        return reward_grid


    def execute(self, command, entity="PLAYER"):
        if command is None:
            return

        if entity == "PLAYER":
            pos = self.player_pos
        elif entity == "GOBLIN":
            pos = self.goblin_pos
        else:
            return

        if command == "UP" and pos[0] > 0 and self.grid[pos[0] - 1][pos[1]] != "W":
            pos[0] -= 1
        elif command == "DOWN" and pos[0] < self.rows - 1 and self.grid[pos[0] + 1][pos[1]] != "W":
            pos[0] += 1
        elif command == "LEFT" and pos[1] > 0 and self.grid[pos[0]][pos[1] - 1] != "W":
            pos[1] -= 1
        elif command == "RIGHT" and pos[1] < self.cols - 1 and self.grid[pos[0]][pos[1] + 1] != "W":
            pos[1] += 1


    def display_move(self, move, entity):
        self.execute(move, entity=entity)  # update agent position
        # self.reward_grid = self._generate_reward_grid()
        if self.gui:
            self._draw_grid()  # redraw the grid
            pygame.display.flip()
            time.sleep(self.delay)



game = GridGame()


if __name__ == "__main__":
    # Initialize the game
    game = GridGame(rows=50, cols=50, cell_size=14, render_delay=0.08)


    # Example goal and goblin positions
    goal = game.exit_pos
    goblin_pos = game.goblin_pos

    running = True
    while running:
        #next_move = plan_next_move(game.player_pos, goal, goblin_pos, grid=game.grid, fear_weight=40.0)
        next_move = plan_next_move(game.player_pos, goal, goblin_pos, grid=game.grid, fear_weight=10, danger_zone=5)
        game.display_move(next_move, entity="PLAYER")

        goblin_move = move_goblin_towards_agent(game, 0) 
        game.display_move(goblin_move, entity="GOBLIN")

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            if event.type == pygame.QUIT:
                running = False

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP:
                    game.execute("UP")
                elif event.key == pygame.K_DOWN:
                    game.execute("DOWN")
                elif event.key == pygame.K_LEFT:
                    game.execute("LEFT")
                elif event.key == pygame.K_RIGHT:
                    game.execute("RIGHT")


        if game.player_pos == goal:
            print("Goal reached!")
            running = False
        if game.player_pos == goblin_pos:
            print("Caught by goblin!")
            running = False





# game = GridGame()
# if __name__ == "__main__":
#     running = True
#     while running:
#         for event in pygame.event.get():
#             if event.type == pygame.QUIT:
#                 running = False

#         game._draw_grid()
#         pygame.display.flip()
