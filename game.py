import pygame
from pygame import Rect
import time
import random

class GridGame:
    def __init__(self, rows=50, cols=50, cell_size=14, render_delay=0.1):
        self.rows = rows
        self.cols = cols
        self.cell_size = cell_size
        self.screen_size = self.screen_size = (cols * cell_size, rows * cell_size)
        self.delay = render_delay

        # Colors
        self.COLOR_WALL = (139, 69, 19)     # brown
        self.COLOR_FLOOR = (169, 169, 169)  # gray
        self.COLOR_PLAYER = (255, 255, 0)   # yellow
        self.COLOR_GOBLIN = (0, 255, 0)     # green
        self.COLOR_EXIT = (255, 0, 0)       # red
        self.COLOR_GRID = (0, 0, 0)         # black grid lines
        self.BLACK = self.COLOR_GRID
        self.WHITE = (255, 255, 255)        # white

        # Player position
        self.pos = [0, 0]

        # Pygame setup
        pygame.init()
        pygame.display.init()
        self.screen = pygame.display.set_mode(self.screen_size)
        pygame.display.set_caption("Maze")
        self.clock = pygame.time.Clock()

        # Generate dungeon map
        self.grid = self._generate_maze()
        self.reward_grid = self._generate_reward_grid()

        # Find player and exit
        self.player_pos = self._find_spawn()
        self.exit_pos = self._place_exit()
        self.goblin_pos = self._place_goblin()

    def _draw_grid(self):
        for row in range(self.rows):
            for col in range(self.cols):
                rect = Rect(col * self.cell_size,
                            row * self.cell_size,
                            self.cell_size,
                            self.cell_size)

                # Choose color based on tile type
                tile = self.grid[row][col]
                if [row, col] == self.player_pos:
                    color = self.COLOR_PLAYER
                elif [row, col] == self.exit_pos:
                    color = self.COLOR_EXIT
                elif [row, col] == self.goblin_pos:
                    color = self.COLOR_GOBLIN
                elif tile == "W":
                    color = self.COLOR_WALL
                else:
                    color = self.COLOR_FLOOR

                pygame.draw.rect(self.screen, color, rect)
                pygame.draw.rect(self.screen, self.COLOR_GRID, rect, width=1)

    def _generate_maze(self):
        """
        Generates a dungeon/map by building a 2D python list.
        The list is of size self.rows by self.cols. This method
        generates each entry of the list 1 at a time. For each
        entry, it will assign it the string "F" with 0.75 probability,
        denoting that cell as a floor. With 0.25 probability, it will
        assign it the string "W", denoting it as a Wall.
        """
        grid = []
        for row in range(self.rows):
            grid_row = []
            for col in range(self.cols):
                # Randomly choose wall or floor
                if random.random() < 0.25:  # 25% chance of wall
                    grid_row.append("W")
                else:
                    grid_row.append("F")
            grid.append(grid_row)
        return grid
    

    def _find_spawn(self):
        """
        Locates all valid spawning cells for the agent in the left region
        of the dungeon/maze generated by _generate_maze(), and then randomly selects one as the
        spawn point. A valid spawn cell is any cell that isn't a wall.
        """
        potential_spawns = []
        for row in range(self.rows):
            for col in range(5):  # only check first 5 columns
                if self.grid[row][col] == "F":
                    potential_spawns.append([row, col])
        return random.choice(potential_spawns)
    
    def _place_exit(self):
        """
        Locates all valid exit cells for the agent in the right region
        of the dungeon/maze generated by _generate_maze(), and then randomly selects one as the
        exit point. A valid exit cell is any cell that isn't a wall.
        """
        potential_exits = []
        for row in range(self.rows - 1, -1, -1):
            for col in range(self.cols - 1, self.cols - 6, -1):
                if self.grid[row][col] == "F":
                    potential_exits.append([row, col])
        return random.choice(potential_exits)
    
    def _place_goblin(self):
        """
        Locates all valid goblin spawn cells in the middle region of the
        dungeon/maze generated by _generate_maze(), and then randomly selects
        one as the goblin spawn. A valid spawn cell is any cell that isn't a wall.
        """
        potential_goblin_spawns = []
        for row in range(self.rows // 3, 2 * self.rows // 3):
            for col in range(self.cols // 3, 2 * self.cols // 3):
                if self.grid[row][col] == "F":
                    potential_goblin_spawns.append([row, col])
        return random.choice(potential_goblin_spawns)
    
    def _generate_reward_grid(self):
        """
        This method looks at the maze generated by _generate_maze() and creates
        a grid of rewards. Rewards on the grid are associated with their respective
        locations in the maze. For example, the reward stored at row 5 column 3 is
        the reward for being at row 5 column 3.
        """
        if self.grid == None: # Make sure a maze has been generated first
            return None
        
        reward_grid = list.copy(self.grid)
        for row in range(self.rows):
            for col in range(self.cols):
                if reward_grid[row][col] == "W": # -100000 Reward for Walls
                    reward_grid[row][col] = -100000
                elif abs(self.goblin_pos[0] - row) <= 5 and abs(self.goblin_pos[1] - col) <= 5: # Reward for being near goblin is based on distance
                    reward_grid[row][col] = min(-10 - abs(self.goblin_pos[0] - 5), -10 - abs(self.goblin_pos[1]))
                elif [row, col] == self.exit_pos: # Reward for winning is really large
                    reward_grid[row, col] == 10000
                else:
                    reward_grid[row][col] = 1 # Reward for a normal state is small but positive
        return reward_grid
        



    def execute(self, command):
        #TODO: needs to be implemented
        pass

    def _loop(self):
        #TODO: needs to be implemented
        pass


game = GridGame()
if __name__ == "__main__":
    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

        game._draw_grid()
        pygame.display.flip()
        game._loop()
