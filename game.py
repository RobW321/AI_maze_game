from heapq import heappush, heappop
from random import random

import pygame
from pygame import Rect
import time
import heapq

class GridGame:
    def __init__(self, rows=50, cols=50, cell_size=14, render_delay=0.1):
        self.rows = rows
        self.cols = cols
        self.cell_size = cell_size
        self.screen_size = self.screen_size = (cols * cell_size, rows * cell_size)
        self.delay = render_delay

        # Colors
        self.COLOR_WALL = (139, 69, 19)  # brown
        self.COLOR_FLOOR = (169, 169, 169)  # gray
        self.COLOR_PLAYER = (255, 255, 0)  # yellow
        self.COLOR_GOBLIN = (0, 255, 0)  # green
        self.COLOR_EXIT = (255, 0, 0)  # red
        self.COLOR_GRID = (0, 0, 0)  # black grid lines
        self.BLACK = self.COLOR_GRID
        self.WHITE = (255, 255, 255)  # white


        # Player position
        self.pos = [0, 0]

        # Pygame setup
        pygame.init()
        pygame.display.init()
        self.screen = pygame.display.set_mode(self.screen_size)
        pygame.display.set_caption("Maze")
        self.clock = pygame.time.Clock()

        # Generate dungeon map
        self.grid = self._generate_maze()

        # Find player and exit
        self.player_pos = self._find_spawn()
        self.exit_pos = self._place_exit()
        self.goblin_pos = self._place_goblin()

    def _draw_grid(self):
        for row in range(self.rows):
            for col in range(self.cols):
                rect = Rect(col * self.cell_size,
                            row * self.cell_size,
                            self.cell_size,
                            self.cell_size)

                # Choose color based on tile type
                tile = self.grid[row][col]
                if [row, col] == self.player_pos:
                    color = self.COLOR_PLAYER
                elif [row, col] == self.exit_pos:
                    color = self.COLOR_EXIT
                elif [row, col] == self.goblin_pos:
                    color = self.COLOR_GOBLIN
                elif tile == "W":
                    color = self.COLOR_WALL
                else:
                    color = self.COLOR_FLOOR

                pygame.draw.rect(self.screen, color, rect)
                pygame.draw.rect(self.screen, self.COLOR_GRID, rect, width=1)
       # pygame.display.flip()

    def _generate_maze(self):
        """
        Generates a dungeon/map by building a 2D python list.
        The list is of size self.rows by self.cols. This method
        generates each entry of the list 1 at a time. For each
        entry, it will assign it the string "F" with 0.75 probability,
        denoting that cell as a floor. With 0.25 probability, it will
        assign it the string "W", denoting it as a Wall.
        """
        grid = []
        for row in range(self.rows):
            grid_row = []
            for col in range(self.cols):
                # Randomly choose wall or floor
                if random.random() < 0.25:  # 25% chance of wall
                    grid_row.append("W")
                else:
                    grid_row.append("F")
            grid.append(grid_row)
        return grid

    def _find_spawn(self):
        """
        Locates all valid spawning cells for the agent in the left region
        of the dungeon/maze generated by _generate_maze(), and then randomly selects one as the
        spawn point. A valid spawn cell is any cell that isn't a wall.
        """
        potential_spawns = []
        for row in range(self.rows):
            for col in range(5):  # only check first 5 columns
                if self.grid[row][col] == "F":
                    potential_spawns.append([row, col])
        return random.choice(potential_spawns)

    def _place_exit(self):
        """
        Locates all valid exit cells for the agent in the right region
        of the dungeon/maze generated by _generate_maze(), and then randomly selects one as the
        exit point. A valid exit cell is any cell that isn't a wall.
        """
        potential_exits = []
        for row in range(self.rows - 1, -1, -1):
            for col in range(self.cols - 1, self.cols - 6, -1):
                if self.grid[row][col] == "F":
                    potential_exits.append([row, col])
        return random.choice(potential_exits)

    def _place_goblin(self):
        """
        Locates all valid goblin spawn cells in the middle region of the
        dungeon/maze generated by _generate_maze(), and then randomly selects
        one as the goblin spawn. A valid spawn cell is any cell that isn't a wall.
        """
        potential_goblin_spawns = []
        for row in range(self.rows // 3, 2 * self.rows // 3):
            for col in range(self.cols // 3, 2 * self.cols // 3):
                if self.grid[row][col] == "F":
                    potential_goblin_spawns.append([row, col])
        return random.choice(potential_goblin_spawns)

    def execute(self, command):
        if command == "UP" and self.player_pos[0] > 0 and self.grid[self.player_pos[0] - 1][self.player_pos[1]] != "W":
            self.player_pos[0] -= 1
        elif command == "DOWN" and self.player_pos[0] < self.rows - 1 and self.grid[self.player_pos[0] + 1][self.player_pos[1]] != "W":
            self.player_pos[0] += 1
        elif command == "LEFT" and self.player_pos[1] > 0 and self.grid[self.player_pos[0]][self.player_pos[1] - 1] != "W":
            self.player_pos[1] -= 1
        elif command == "RIGHT" and self.player_pos[1] < self.cols - 1 and self.grid[self.player_pos[0]][self.player_pos[1] + 1] != "W":
            self.player_pos[1] += 1

    def display_move(self, move):
        self.execute(move)  # update agent position
        self._draw_grid()  # redraw the grid
        time.sleep(self.delay)
        pygame.display.flip()


game = GridGame()


def plan_next_move(player_pos, goal, goblin_pos, grid=None):
    rows = len(grid)
    cols = len(grid[0])

    start = tuple(player_pos)
    goal = tuple(goal)

    # Moves → (delta_row, delta_col, command_string)
    moves = [
        (-1, 0, "UP"),
        (1, 0, "DOWN"),
        (0, -1, "LEFT"),
        (0, 1, "RIGHT")
    ]

    # Priority queue for A*
    pq = []
    heapq.heappush(pq, (0, start))  # (priority, position)

    came_from = {start: None}
    cost_so_far = {start: 0}

    def heuristic(a, b):
        # Manhattan distance
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    while pq:
        _, current = heapq.heappop(pq)

        if current == goal:
            break

        for dr, dc, cmd in moves:
            nr = current[0] + dr
            nc = current[1] + dc
            nxt = (nr, nc)

            # Check bounds
            if not (0 <= nr < rows and 0 <= nc < cols):
                continue

            # Check wall
            if grid[nr][nc] == "W":
                continue

            new_cost = cost_so_far[current] + 1

            if nxt not in cost_so_far or new_cost < cost_so_far[nxt]:
                cost_so_far[nxt] = new_cost
                priority = new_cost + heuristic(nxt, goal)
                heapq.heappush(pq, (priority, nxt))
                came_from[nxt] = current

    # If goal unreachable
    if goal not in came_from:
        return None  # or choose a random safe move?

    # Reconstruct path backwards
    path = []
    node = goal
    while node != start:
        path.append(node)
        node = came_from[node]
    path.reverse()

    # Determine next step
    next_row, next_col = path[0]

    # Convert next position → command
    r, c = player_pos

    if next_row == r - 1:
        return "UP"
    if next_row == r + 1:
        return "DOWN"
    if next_col == c - 1:
        return "LEFT"
    if next_col == c + 1:
        return "RIGHT"

    return None

def manhattan_distance_bad(pos1, pos2):
   dx = abs(pos1[0] - pos2[0])
   dy = abs(pos1[1] - pos2[1])
   manhattan = dx + dy


   noise = random.uniform(0.2, 0.4) * manhattan #can change the noise error, depending on visualization
   return manhattan + noise




def distance(pos):
   return manhattan_distance_bad(pos[0], pos[1])

def move_goblin_towards_agent(self, random_chance):
    # manhattan distance to agent heuristic, but random chance it moves to random place

    if random.randint(1, 100) <= random_chance:
        goblin_x, goblin_y = self.goblin_pos
        potential_moves = [
            [goblin_x - 1, goblin_y],  # Up
            [goblin_x + 1, goblin_y],  # Down
            [goblin_x, goblin_y - 1],  # Left
            [goblin_x, goblin_y + 1]  # Right
        ]

        valid_moves = [
            [x, y] for x, y in potential_moves
            if 0 <= x < self.rows and 0 <= y < self.cols and self.grid[x][y] != "W"
        ]

        if valid_moves:
            self.goblin_pos = random.choice(valid_moves)
        return self.goblin_pos

    # A* implementation:
    start = tuple(self.goblin_pos)
    goal = tuple(self.player_pos)

    open_set = []
    heappush(open_set, (manhattan_distance_bad(start, goal), 0, start, [start]))

    visited = set()

    while open_set:
        f_score, g_score, current, path = heappop(open_set)

        # If we reached the agent, return only the first move in the path
        if current == goal:
            if len(path) > 1:
                # Take only the first step from the path
                self.goblin_pos = list(path[1])
            return self.goblin_pos

        if current in visited:
            continue
        visited.add(current)

        # Explore possible neighbors
        x, y = current
        neighbors = [
            (x - 1, y),  # Up
            (x + 1, y),  # Down
            (x, y - 1),  # Left
            (x, y + 1)  # Right
        ]

        for neighbor in neighbors:
            n_x, n_y = neighbor

            # Check if neighbor is valid
            if (0 <= n_x < self.rows and
                    0 <= n_y < self.cols and
                    self.grid[n_x][n_y] != "W" and
                    neighbor not in visited):
                new_g_score = g_score + 1
                new_f_score = new_g_score + manhattan_distance_bad(neighbor, goal)
                new_path = path + [neighbor]

                heappush(open_set, (new_f_score, new_g_score, neighbor, new_path))

        # If no path found, the goblin stays in place
    return self.goblin_pos


if __name__ == "__main__":
    # Initialize the game
    #game = GridGame(cell_height=50, cell_width=50, render_delay=0.2)
    game = GridGame(rows=50, cols=50, cell_size=14, render_delay=0.2)


    # Example goal and goblin positions
    goal = game.exit_pos
    goblin_pos = game.goblin_pos

    running = True #false for now, cuz it keeps loading a lot
    while running:
        next_move = plan_next_move(game.player_pos, goal, goblin_pos, grid=game.grid)

        game.display_move(next_move)

        goblin_pos = move_goblin_towards_agent(goblin_pos, game.player_pos)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            if event.type == pygame.QUIT:
                running = False

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP:
                    game.execute("UP")
                elif event.key == pygame.K_DOWN:
                    game.execute("DOWN")
                elif event.key == pygame.K_LEFT:
                    game.execute("LEFT")
                elif event.key == pygame.K_RIGHT:
                    game.execute("RIGHT")


        if game.player_pos == goal:
            print("Goal reached!")
            running = False





# game = GridGame()
# if __name__ == "__main__":
#     running = True
#     while running:
#         for event in pygame.event.get():
#             if event.type == pygame.QUIT:
#                 running = False

#         game._draw_grid()
#         pygame.display.flip()
